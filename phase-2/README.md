# فاز دوم — پیاده‌سازی کامل و تست الگوریتم‌ها

<div class="md-flex">
  <div class="md-text">
    پروژه درس <strong>طراحی الگوریتم‌ها</strong> فاز دوم - ترم 4041<br>
    نام دانشجو: <strong>محمدرضا اورعی</strong> <br>
    شماره دانشجویی: <strong>40318253</strong>
  </div>
  <div class="md-image">
    <img src="loho2.png" alt="logo">
  </div>
</div>


در فاز ۲، علاوه بر تکمیل پیاده‌سازی ساختار داده‌ی گراف معنایی و مجموعه‌ی الگوریتم‌های جستجو (برای یافتن مسیرهای مفهومی بین گره‌ها)، تمرکز اصلی پروژه از «صرفاً پیاده‌سازی» به سمت ارزیابی عملی حرکت می‌کند؛ یعنی با تعریف سناریوهای متنوع، اجرای تست‌های منظم و بررسی حالت‌های شکست، صحت خروجی‌ها و پایداری سیستم سنجیده می‌شود و در کنار آن با تحلیل‌های تجربی (مثل زمان اجرا و رفتار در مقیاس‌های مختلف) تلاش می‌شود کیفیت و کارایی راه‌حل در شرایط واقعی هم قابل اتکا باشد.

## فهرست مطالب

- [۲. تست (Testing & Validation)](#۲-تست-testing--validation)
- [۳. تحلیل عملکرد (Empirical Analysis)](#۳-تحلیل-عملکرد-empirical-analysis)
- [۴. مقایسه روش‌ها (در صورت وجود بیش از یک الگوریتم)](#۴-مقایسه-روشها-در-صورت-وجود-بیش-از-یک-الگوریتم)
- [۵. استفاده از LLM (در صورت وجود)](#۵-استفاده-از-llm-در-صورت-وجود)
- [۶. بهبود الگوریتم](#۶-بهبود-الگوریتم)
- [تحلیل عملکرد](#تحلیل-عملکرد)
- [۷. وب‌دمو با Django](#۷-وبدمو-با-django)

<div style="page-break-after: always;"></div>

## 1. ساختار پروژه
![[startcture.png]]

- فایل `src/semantic_graph.py`: پیاده‌سازی کامل ساختار گراف معنایی و متدهای سطح‌بالای جستجو.
- فایل `src/algorithms.py`: پیاده‌سازی کامل الگوریتم‌های BFS, DFS, Dijkstra, A*, Floyd–Warshall و `SemanticBFS`, `SemanticDijkstra`, `SemanticAStar`, `HybridSearch`.
- فایل `src/analysis.py`: اتصال به تحلیل پیچیدگی و متریک‌های گراف (استفاده از ماژول `analysis.py` اصلی).
- فولدر `demo_web/`: وب‌دموی ساده مبتنی بر Django برای نمایش مسیرهای معنایی بین مفاهیم.
- فولدر `Performance_Analysis/`: اسکریپت‌های تحلیل عملکرد (بنچمارک، تولید نمودار و گزارش‌های تجربی).


## ۲. تست (Testing & Validation)
در این فاز، برای اطمینان از صحت و پایداری پیاده‌سازی، سناریوهای تست زیر در نظر گرفته شده است.
- ** ۱۰ ورودی واقعی** : در این پروژه، «ورودی واقعی» به‌معنای مجموعه‌ای از مفاهیم و روابط معنایی است که در دنیای واقعی معنا دارند. نمونه سناریوها:
	  1. **دامنه‌ی هوش مصنوعی**: مفاهیمی مانند `AI`, `Machine Learning`, `Deep Learning`, `Neural Network`, `Data`, `Model`, `Training`, `Inference`.  
	  2. **دامنه‌ی گراف و الگوریتم‌ها**: `Graph`, `Node`, `Edge`, `Path`, `BFS`, `DFS`, `Dijkstra`, `A*`, `Shortest Path`.  
	  3. **دامنه شهرها و مسیرها**: شهرهای واقعی (تهران، شیراز، اصفهان، مشهد، تبریز، قم، رشت، اهواز) با شباهت بر اساس فاصله جغرافیایی یا خطوط حمل‌ونقل.  
	  4. **دامنه دروس دانشگاهی**: `Algorithms`, `Data Structures`, `Operating Systems`, `Databases`, `Computer Networks`, `AI`, `Machine Learning`.  
	  5. **دامنه مترادف‌ها و نزدیک‌معناها**: جفت‌هایی مانند (سریع، تند)، (آرام، کند)، (بزرگ، عظیم)، (کوچک، ریز). 
	  6. **دامنه تکنولوژی وب**: `HTTP`, `REST`, `API`, `Frontend`, `Backend`, `Database`, `Cache`.  
	  7. **دامنه مالی**: `Bank`, `Loan`, `Interest`, `Risk`, `Investment`, `Stock`, `Bond`.  
	  8. **دامنه ترجمه فارسی–انگلیسی**: مفاهیم دوزبانه مانند (`کتاب`, `Book`)، (`دانشگاه`, `University`)، برای تست گره‌های دو زبانه.  
	  9. **دامنه مفاهیم عمومی**: `Animal`, `Dog`, `Cat`, `Bird`, `Mammal`, `Pet`.  
	  10. **دامنه دلخواه دانشجو** (موضوع پروژه اصلی یا علاقه شخصی) که با استفاده از مدل امبدینگ فارسی ساخته می‌شود (مثلاً `persian-embeddings.gguf` برای محاسبه شباهت‌ها).


- **ورودی‌های ساده، متوسط و سخت**  
  برای هر دامنه، سه نوع سناریو در نظر گرفته می‌شود:
	  - **ساده**: گراف کوچک (۴–۶ گره) با ساختار تقریباً خطی یا درختی، مسیر واضح و کوتاه بین مبدأ و مقصد؛ مناسب برای تست دستی و دیباگ اولیه.  
	  - **متوسط**: گراف با ۱۰–۳۰ گره و چند مسیر ممکن بین مبدأ و مقصد؛ در این سطح تفاوت بین BFS، Dijkstra و A* در طول مسیر و تعداد گره‌های بازدید شده دیده می‌شود.  
	  - **سخت**: گراف‌های بزرگ‌تر (۵۰ گره به بالا) با چگالی متفاوت (پراکنده/متراکم)، وزن‌های شباهت نزدیک به هم و وجود حلقه‌ها؛ این سناریوها برای تست کارایی، حساسیت به آستانه شباهت و رفتار الگوریتم Hybrid استفاده می‌شوند.

- **تحلیل سناریوهای شکست (Failure Cases)**  
  در کنار سناریوهای موفق، موارد زیر به‌عنوان سناریوهای شکست تحلیل می‌شوند:
![[Failure Cases.png]]

  - **عدم وجود مسیر**: انتخاب جفت گره‌هایی که در گراف هیچ مسیر معنایی بین آن‌ها وجود ندارد (یا به‌علت آستانه شباهت بالاتر حذف شده‌اند) و بررسی این‌که الگوریتم‌ها مسیر خالی برگردانند و به‌درستی این وضعیت را گزارش کنند.  
  - **شباهت‌های مبهم یا متناقض**: گرافی که در آن چند مسیر با شباهت‌های تقریباً برابر وجود دارد؛ بررسی این‌که Dijkstra/A* کدام مسیر را انتخاب می‌کنند و چرا.  
  - **گره‌ها یا یال‌های نویزی**: اضافه‌کردن مفاهیم یا یال‌هایی با شباهت پایین/اشتباه (از خروجی مدل امبدینگ) و بررسی مقاومت الگوریتم‌ها در برابر نویز (با تنظیم `similarity_threshold`).  
  - **پارامترهای نامناسب**: مثال‌هایی که در آن انتخاب آستانه شباهت خیلی پایین یا خیلی بالا باعث رفتار غیرمنتظره می‌شود (گراف خیلی متراکم یا خیلی پراکنده) و نشان داده می‌شود که چگونه با تنظیم پارامترها این مشکل رفع می‌شود.

<div style="page-break-after: always;"></div>

## ۳. تحلیل عملکرد (Empirical Analysis)
در این بخش، نتایج تست‌های فاز ۲ به‌صورت تجربی اندازه‌گیری و با تحلیل تئوری فاز ۱ مقایسه می‌شود.
![[Empirical Analysis.png]]
- **اندازه‌گیری زمان اجرای واقعی**  
  - برای هر الگوریتم (`SemanticBFS`, `SemanticDijkstra`, `SemanticAStar`, `HybridSearch`) و برای چند اندازه‌ی مختلف گراف (کوچک، متوسط، بزرگ)، زمان اجرای واقعی اندازه‌گیری می‌شود.  
  - از ابزارهای ساده‌ی زمان‌سنجی (مانند `time.perf_counter()` در پایتون) استفاده می‌شود و برای کاهش نوسان، هر سناریو چند بار اجرا و میانگین زمان محاسبه می‌گردد.  
  - نتایج در قالب جدول و نمودار (زمان بر حسب تعداد گره/یال) ارائه می‌شود تا روند رشد زمانی با Big-O تئوری مقایسه شود.

- **اندازه‌گیری مصرف حافظه**  
  - با استفاده از ابزارهایی مانند `tracemalloc` یا پروفایلرهای حافظه، اوج مصرف حافظه در طول اجرای هر الگوریتم روی سناریوهای مختلف ثبت می‌شود.  
  - تمرکز روی مقایسه‌ی نسبی بین الگوریتم‌ها است (مثلاً Dijkstra/A* در مقابل BFS) و بررسی این‌که آیا الگوی رشد حافظه با تحلیل تئوری \(O(V)\) و \(O(V^2)\) سازگار است یا خیر.  
  - برای گراف‌های خیلی بزرگ، محدودیت‌های حافظه (مثلاً برای Floyd–Warshall) به‌طور خاص مستند می‌شود.

- **تحلیل رفتار الگوریتم در مقیاس‌های مختلف**  
  - برای گراف‌های **پراکنده** و **متراکم**، تعداد گره‌های بازدیدشده، طول مسیر پیدا شده و زمان اجرا مقایسه می‌شود.  
  - رفتار Hybrid در شرایط مختلف (وقتی BFS کافی است و وقتی مجبور است به Dijkstra سوئیچ کند) به‌صورت تجربی تحلیل می‌شود.  
  - تأثیر انتخاب آستانه شباهت (`similarity_threshold`) و پارامترهای heuristic در A* بر کارایی و کیفیت مسیر بررسی و با مثال عددی نشان داده می‌شود.

- **مقایسه با تحلیل تئوری فاز ۱**  
  - برای هر الگوریتم، نتایج تجربی (نمودار زمان و حافظه) کنار تحلیل Big-O تئوری فاز ۱ قرار می‌گیرد و شباهت یا تفاوت‌ها توضیح داده می‌شود.  
  - در مواردی که رفتار واقعی بهتر از بدترین حالت تئوری است (مثلاً A* با heuristic خوب)، دلیل این تفاوت با استناد به ساختار گراف و توزیع وزن‌ها تحلیل می‌شود.  
  - در نهایت، یک جمع‌بندی ارائه می‌شود که برای چه نوع گراف و چه محدوده‌ی اندازه‌ای، کدام الگوریتم از نظر عملی بهترین انتخاب است و این نتیجه چگونه با توصیه‌های نظری فاز ۱ هماهنگ است.

## ۴. مقایسه روش‌ها 
در این پروژه چند الگوریتم مختلف برای جستجو روی گراف معنایی پیاده‌سازی شده است؛ در این بخش آن‌ها را از سه جنبه مقایسه می‌کنیم.

- **مزایا و معایب هر الگوریتم**  
  - روش **Semantic BFS**  
    - مزایا: پیاده‌سازی ساده، سرعت خوب در گراف‌های کوچک و در زمانی که مسیر کوتاه وجود دارد؛ مناسب برای سناریوهای real‑time ساده.  
    - معایب: لزوماً مسیر بهینه (بیشترین شباهت) را تضمین نمی‌کند و در گراف‌های بزرگ ممکن است تعداد زیادی گره بررسی کند.  
  - روش **Semantic Dijkstra**  
    - مزایا: تضمین یافتن مسیر بهینه براساس تعریف هزینه (مثلاً \(-\log(sim)\))؛ رفتار پایدار در گراف‌های مختلف.  
    - معایب: از BFS سنگین‌تر است؛ در گراف‌های خیلی بزرگ یا متراکم زمان و حافظه بیشتری مصرف می‌کند.  
  - روش **Semantic A\***  
    - مزایا: با داشتن heuristic خوب، تعداد گره‌های بررسی‌شده و زمان اجرا کمتر از Dijkstra می‌شود؛ برای سناریوهایی که هدف مشخص و اطلاعات تقریبی از فاصله معنایی داریم بسیار مناسب است.  
    - معایب: نیازمند طراحی heuristic معتبر و مناسب است؛ در صورت heuristic ضعیف، عملاً به Dijkstra نزدیک می‌شود.  
  - روش **Hybrid (BFS + Dijkstra)**  
    - مزایا: تلاش برای ترکیب سادگی و سرعت BFS با بهینگی Dijkstra؛ در بسیاری از گراف‌های واقعی ابتدا با هزینه کم BFS را امتحان کرده و فقط در صورت لزوم سراغ Dijkstra می‌رود.  
    - معایب: در بدترین حالت ممکن است هر دو الگوریتم اجرا شوند و هزینه زمانی تقریباً برابر Dijkstra داشته باشد.

- **پیچیدگی تئوری**  
  - طبق فاز ۱ و ماژول `analysis.py`:  
    - روش **BFS/DFS**: زمان \(O(V + E)\)، فضا \(O(V)\).  
    - روش **Dijkstra / A\***: زمان \(O((V + E)\log V)\)، فضا \(O(V)\).  
    - روش **Floyd–Warshall** (برای همه‌مسیرها): زمان \(O(V^3)\)، فضا \(O(V^2)\).  
  - این مقایسه نشان می‌دهد که برای گراف‌های بزرگ و متراکم، استفاده‌ی بی‌ملاحظه از Floyd–Warshall عملی نیست و باید بیشتر بر Dijkstra/A* یا Hybrid تکیه کرد، در حالی‌که برای گراف‌های کوچک یا زمانی که همه‌مسیرها نیاز است، Floyd–Warshall توجیه‌پذیر است.

- **مقایسه عملکرد واقعی (بر اساس نتایج تجربی فاز ۲)**  
  - در گراف‌های کوچک و مسیرهای کوتاه، **BFS** معمولاً سریع‌ترین است و سربار ساختارهای داده‌ی پیچیده را ندارد.  
  - در گراف‌های متوسط و بزرگ که کیفیت مسیر مهم است، **Dijkstra** و به‌خصوص **A\*** (با heuristic خوب) از نظر تعادل بین زمان اجرا و کیفیت مسیر برتری دارند.  
  - الگوریتم **Hybrid** در بسیاری از سناریوهای عملی، نزدیک به Dijkstra از نظر کیفیت و نزدیک به BFS از نظر زمان عمل می‌کند و برای «انتخاب پیش‌فرض» در کاربردهای عمومی پیشنهاد می‌شود.  
  - نقاط شکست و سناریوهای خاص (مثلاً گراف‌های بسیار متراکم یا دارای یال‌های با شباهت بسیار نزدیک) در گزارش فاز ۲ مستند می‌شوند تا نشان داده شود کجا باید از انتخاب الگوریتم پیش‌فرض فاصله گرفت.

<div style="page-break-after: always;"></div>

## ۵. استفاده از LLM 
در فاز ۲، ماژول مبتنی بر LLM/Embedding پیاده‌سازی شده است تا بتوانیم کیفیت گراف معنایی و مسیرهای پیدا شده را بهبود دهیم و همچنین رفتار سیستم را با و بدون LLM مقایسه کنیم. در این پروژه از مدل زبانی persian-embeddings.gguf استفاده شده است.

- **ادغام ماژول LLM در پیاده‌سازی**  
  - ماژول اصلی برای این کار `similarity.py` است که چند کلاس محاسبه شباهت دارد (`EmbeddingSimilarity`, `LLMSimilarity`, `SimpleWordSimilarity`).  
  - در سناریوهای واقعی فاز ۲، از یک مدل امبدینگ فارسی (در این پروژه فایل `persian-embeddings.gguf`) به‌عنوان backend برای `EmbeddingSimilarity`/`LLMSimilarity` استفاده می‌شود؛ به‌این صورت که: 
  ![[image (3).png]]
    - برای هر مفهوم، بردار امبدینگ با مدل فارسی محاسبه می‌شود.  
    - شباهت بین دو مفهوم با cosine similarity بین بردارها به دست می‌آید و به بازه \([0, 1]\) نرمال‌سازی می‌شود.  
    - این مقدار به‌طور مستقیم به‌عنوان وزن یال در ساخت گراف (`build_semantic_graph_from_texts`) استفاده می‌شود.  

- **ارزیابی کیفیت خروجی با و بدون LLM**  
![[llm_impact_infographic.png]]
  
به‌صورت کلی حالت LLM/Embedding بهتره 
- [کیفیت معنایی] معمولاً مسیرها از نظر معنا منطقی‌تر می‌شوند و ارتباطات پنهان بین مفاهیم فارسی بهتر کشف می‌شود؛ این همان جایی است که Rule-based (همپوشانی کلمات) ضعیف‌تر است.
- [هزینه محاسباتی] تقریباً همیشه کندتر/گران‌تر است، چون باید برای زوج‌مفهوم‌ها embedding بگیرد و similarity محاسبه کند (در نمودارهای زمان ساخت گراف باید افزایش زمان را ببینی).

اما با توجه به اینکه دیتا ها ساده هستند، اثر LLM واضح نیست و ستون‌های LLM خیلی کوچک/صفر شده‌اند و این نشان دهنده سرعت بیشتر LLM نسبت به حالت عادی هست.


## ۶. بهبود الگوریتم
این بخش به ایده‌های پیشنهادی برای **بهینه‌تر کردن الگوریتم‌ها** در فاز ۲ می‌پردازد.

- **نسخه‌های بهینه‌تر الگوریتم‌ها**  
  - برای BFS و DFS می‌توان از ساختارهای داده‌ی سبک‌تر و حذف logهای غیرضروری استفاده کرد تا در تست‌های استرسی (گراف‌های بسیار بزرگ) سربار کاهش یابد.  
  - برای Dijkstra/A* استفاده از **priority queue کارآمدتر** (مثلاً heap باینری موجود در `heapq` یا در صورت نیاز ساختارهای پیشرفته‌تر مثل Fibonacci heap) در سناریوهای بسیار بزرگ می‌تواند زمان را بهبود دهد؛ در این پروژه به‌دلیل سادگی، heap باینری کفایت می‌کند اما در تحلیل به این امکان اشاره می‌شود.  
  - در Hybrid، مقدار بهینه‌ی `bfs_depth_limit` بر اساس نتایج تجربی فاز ۲ تنظیم می‌شود (مثلاً ۲، ۳ یا ۴) تا تعادل بهتر بین سرعت و کیفیت مسیر ایجاد شود.

- حالت **Heuristicهای بهتر برای A\***  
  - تعریف heuristic بر اساس **فاصله در فضای امبدینگ**: برای هر گره، فاصله‌ی کسینوسی بین امبدینگ آن و امبدینگ گره هدف به‌عنوان تخمینی از «فاصله معنایی» استفاده می‌شود.  
  - اعمال **نرمال‌سازی مناسب** روی این فاصله (مثلاً تبدیل به هزینه‌ی تقریبی \(-\log(sim)\)) تا با هزینه‌های یال‌ها سازگار باشد و خاصیت *admissible* بودن heuristic حفظ شود.  
  - بررسی چند heuristic مختلف (ساده، قوی‌تر، ترکیبی) در فاز ۲ و مقایسه‌ی تعداد گره‌های بررسی‌شده و زمان اجرا برای انتخاب بهترین گزینه.

- **روش‌های سریع‌تر یا دقیق‌تر**  
  - استفاده از **pruning مبتنی بر آستانه شباهت پویا**: در طول جستجو، اگر مسیر جاری شباهت کلی بسیار پایینی پیدا کند (مثلاً حاصل‌ضرب شباهت‌ها از یک حد مشخص کمتر شود)، آن شاخه به‌طور زودهنگام قطع (prune) شود.  
  - بهره‌گیری از **pre-computation** برای گراف‌های ثابت: اجرای اولیه‌ی `floyd_warshall_impl` روی گراف‌های کوچک/ثابت و ذخیره‌ی نتایج برای پاسخ‌گویی سریع به پرسش‌های تکراری.  
  - استفاده از ساختارهای کمکی مثل **لیست مرتب‌شده‌ی همسایه‌ها بر اساس شباهت** تا در BFS/Hybrid همیشه محتمل‌ترین یال‌ها زودتر بررسی شوند.

- **تکنیک‌های کاهش پیچیدگی**  
  - **کاهش اندازه گراف (Graph Sparsification)**: حذف یال‌های با شباهت خیلی کم و ادغام گره‌های بسیار مشابه (clustering مفهومی) پیش از اجرای الگوریتم‌ها، تا \(E\) و در نتیجه زمان و حافظه کاهش یابد.  
  - **استفاده از threshold چندسطحی**: اجرای اولیه الگوریتم‌ها با آستانه‌ی بالا برای یافتن مسیرهای بسیار قوی، و در صورت عدم موفقیت، کاهش تدریجی آستانه؛ این کار باعث می‌شود در بسیاری از موارد الگوریتم‌ها روی زیرگراف کوچک‌تری کار کنند.  
  - حالت **Caching نتایج جستجو** برای زوج‌گره‌هایی که زیاد تکرار می‌شوند تا در پرس‌وجوهای بعدی نیاز به اجرای مجدد الگوریتم نباشد و زمان متوسط پاسخ کاهش یابد.

<div style="page-break-after: always;"></div>

## تحلیل عملکرد
این پوشه برای **تحلیل عملکرد (Performance Analysis)** در فاز ۲ ایجاد شده و تمام اسکریپت‌های تولید نمودار و گزارش‌های تجربی در آن متمرکز شده‌اند.

- خروجی‌ها (نمودارها و گزارش‌ها) با استفاده از آرگومان `--output` قابل هدایت به یک مسیر دلخواه هستند.
- به‌صورت پیش‌فرض اگر `--output` ندهید، خروجی‌ها در همان پوشه‌ی `Performance_Analysis/` ذخیره می‌شوند.
- برای اجرای یکجا یا تکی، یک رانر اضافه شده است: `Performance_Analysis/main.py` که خروجی‌ها را به‌صورت پیش‌فرض داخل `Performance_Analysis/output/` ذخیره می‌کند.

### ساختار پوشه

- پوشه **`../outputs/`**
  - محل ذخیره خروجی نمودارها (فایل‌های `.png`).

### فایل‌ها

- فایل **`../generate_perf_chart.py`**

  - تولید «پالت زمان اجرا» روی ۱۰ سناریوی تست (۴ ساده، ۴ متوسط، ۲ سخت) و ذخیره خروجی در `outputs/performance_chart.png`.

- فایل **`../generate_algorithm_comparison_chart.py`**
  - مقایسه‌ی زمان اجرای الگوریتم‌ها روی ۱۰ سناریو (BFS, Dijkstra, A*, Hybrid, Floyd–Warshall) و تولید نمودارهای:
    - `outputs/algorithm_comparison_chart.png`
![[algorithm_comparison_chart.png]]

<div style="page-break-after: always;"></div>

    - `outputs/algorithm_comparison_chart_zoom.png` (نسخه‌ی زوم‌شده برای مقایسه‌ی واضح‌تر بدون غالب شدن Floyd–Warshall)
![[algorithm_comparison_chart_zoom.png]]

- فایل **`../benchmark_scaling.py`**
  - بنچمارک «رفتار الگوریتم‌ها هنگام افزایش اندازه ورودی» با حدود ۱۰۰ تست مصنوعی (افزایش V و تغییر Top-K).
  - خروجی‌ها:
    - `outputs/scaling_chart_zoom.png`
![[phase_2/Performance_Analysis/outputs/scaling_chart_zoom.png]]

<div style="page-break-after: always;"></div>

- فایل **`../generate_time_growth_chart.py`**
  - تولید نمودار رشد زمانی (Time Growth) برای چند اندازه ورودی مشخص و ذخیره خروجی:
    - `outputs/time_growth_chart.png`
![[time_growth_chart.png]]
- فایل **`../generate_big_o_comparison_chart.py`**
  - مقایسه‌ی داده‌های اجرای واقعی با منحنی‌های تئوری Big-O (نرمال‌شده) و ذخیره خروجی:
    - `outputs/big_o_comparison_chart.png`
![[big_o_comparison_chart.png]]
### نحوه اجرا

از داخل پوشه `phase_2` می‌توانید هر کدام از اسکریپت‌ها را اجرا کنید. یا اینکه فایل `main.py` را اجرا کنید مثال:

```bash
python Performance_Analysis/main.py
```

<div style="page-break-after: always;"></div>

## ۷. وب‌دمو با Django

برای نمایش تعاملی گراف معنایی و مسیرهای پیدا شده، یک وب‌دمو ساده با Django در فولدر `demo_web/` پیاده‌سازی شده است.

- **ساختار پروژه‌ی وب**  
  - فایل `demo_web/manage.py`: اسکریپت اجرای سرور Django.  
  - فایل  `demo_web/demo_web/settings.py`, `urls.py`, `wsgi.py`: تنظیمات مینیمال پروژه.  
  - اپلیکیشن `graphdemo` شامل:
    - فایل  `graphdemo/views.py`: ویوی `index` که مفاهیم، مبدأ و مقصد را از فرم می‌گیرد، با استفاده از `phase_2.semantic_graph.SemanticGraph` یک گراف ساده می‌سازد و مسیر بین دو مفهوم را با Dijkstra پیدا می‌کند.  
    - فایل  `graphdemo/templates/graphdemo/index.html`: صفحه‌ی HTML با CSS ساده که فرم ورود مفاهیم و مسیر خروجی را نمایش می‌دهد.  

- **نحوه اجرا**  
  از ریشه‌ی پروژه:

  ```bash
  python manage.py runserver
  ```

  سپس در مرورگر به آدرس `http://127.0.0.1:8000/` ، لیستی از مفاهیم (با ویرگول جدا شده) و گره‌های مبدأ و مقصد را وارد کنید تا مسیر معنایی پیشنهادی روی گراف دمو نمایش داده شود.

<div style="page-break-after: always;"></div>




